import type { NextPage } from 'next'
import Head from 'next/head'
import Link from 'next/link';

import styles from '@/styles/Home.module.css';

const link = { color: 'darkSlateBlue' };

const TurnNextIntoCra: NextPage = () => {
  return (
    <div className={styles.container}>
      <Head>
        <title>ChrisWF.</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.articleMain}>
        <h1>{`Turning NextJS into CRA (don't actually do this)`}</h1>

        <div>
          <p>
            This is roughly an excerpt from <a style={link} href='https://www.youtube.com/c/TheoBrowne1017'>Theo&rsquo;s video</a>
            {' '}aptly titled <a style={link} href='https://www.youtube.com/watch?v=7m14f0ZzMyY'>STOP Using Create React App.</a>
          </p>
          <p>
            It&rsquo;s really more of a thought experiment than a practical development practice.
          </p>
        </div>

        <article>
          <h4>Spin up a new Create React App and take a look at the DOM.</h4>
          <p>What do you see? Look at the elements tab. Your DOM is populated with the various html tags making up your application&rsquo;s components.</p>
          <p>Now look at the network tab. First resource in the waterfall is your html doc. Take a look at this doc&rsquo;s response. You will see something like:</p>
          <code>{`
            <body>
              <div id="root"></div>
            </body>
          `}</code>
          <p>This is the essence of client-side rendering. Create React App relies on browser functionality to create all of the DOM elements at runtime.</p>
        </article>

        <article>
          <h4>Now spin up a new NextJS app and look at the DOM.</h4>
          <p>You will roughly see the same thing in the elements tab as you saw with CRA.</p>
          <p>Again, look at the network tab. Check out the response of the html doc. All of the DOM elements have already been generated.</p>
          <code>{`
            <body>
              <div id="root"><h1>My Cool App</h1><article><h2>Hi</h2><p>Hello World</p></article></div>
            </body>
          `}</code>
          <p>This is the essence of server-side-rendering. We are letting the server (in this case Node) create the DOM elements at runtime, stick them in the HTML, and then they are already there when the browser runs the initial network call for the html doc.</p>
        </article>

        <article>
          <h4>If we want to, we can override how NextJS handles this ahead-of-time code generation.</h4>
          <p>By default, NextJS recognizes any components created and default-exported within the &rsquo;pages&rsquo; folder as a default page of your app to be server-side rendered.</p>
          <p>If we rip out the functionality from one of these &rsquo;pages&rsquo; and place it in its own component file, then use Next Dynamic to import that file in our index file...</p>
          <code>import dynamic from &rsquo;next/dynamic&rsquo;;</code>
          <br />
          <code>{`const LazyHomeComponent = dynamic(() => import("../components/home"), { ssr: false });`}</code>
          <br />
          <code>{`export default function Home() { return <LazyHomeComponent /> }`}</code>
          <p>...and now spin it up and take a look at the html response again.</p>
          <p>The html response once again has an empty div and the core component functionality will be client-side generated at runtime.</p>
          <p>We have now created CRA within NextJS.</p>
        </article>

        <article>
          <p>When might this actually be useful?</p>
          <p>If you have library/package imports that need to run on the client but cannot run on the server.</p>
        </article>
      </main>

      <footer className={styles.footer}>
        <p>
          <Link href="../">
            Home
          </Link>
        </p>
      </footer>
    </div>
  )
}

export default TurnNextIntoCra
